const t="/zh-cn/assets/cover-12543354.png",s="/zh-cn/assets/image1-0a18e154.png",n="/zh-cn/assets/image2-e7e1943c.png",a="/zh-cn/assets/image3-5eef7eef.jpg",e=[t,s,n,a],l={label:"欢迎报名Rust China Hackathon 2022 达坦科技组",description:"12月4日下午，DatenLord就2022Rust China Hackathon大赛活动企业组（达坦科技组）的赛题进行了空中宣讲会。不仅对赛事流程进行了全面的讲解，同时对赛题背景以及完赛标准和要点进行了深入的剖析。会后更是设置问答环节，细致、详尽地解答了大家所提的各种问题，以便大家对赛题有更加充分的理解。",cover:"./cover.png",location:"中国香港",date:"2022-12-08",title:"Welcome to sign up for the Rust China Hackathon 2022 Datan Technology Group"},o=[{label:"赛事日程表",level:2},{label:"参赛福利",level:2},{label:"赛题评审",level:2},{label:"参赛及代码提交",level:2},{label:"赛题剖析",level:2},{label:"达坦科技 DatenLord 赛题",level:2}],p=`<p>12 月 4 日下午，DatenLord 就 <strong>2022Rust China Hackathon</strong> 大赛活动企业组（达坦科技组）的赛题进行了空中宣讲会。不仅对赛事流程进行了全面的讲解，同时对赛题背景以及完赛标准和要点进行了深入的剖析。会后更是设置问答环节，细致、详尽地解答了大家所提的各种问题，以便大家对赛题有更加充分的理解。</p>
<p>本届 Hackathon 为 Rust 中文社区举办的第一届的线上黑客马拉松，大赛主题为「<strong>RustForFun</strong>」，分为「<strong>社区组</strong>」与「<strong>企业组</strong>」。达坦科技作为本届 Hackathon 的协办方，赞助参与本次企业组赛道。希望借此机会激发大家对 Rust 语言的学习热情，提高应用 Rust 的能力，同时结识志趣相投的好友，一起进行思维的碰撞。</p>
<h2 id="赛事日程表">赛事日程表</h2>
<ul>
<li><strong>报名+组队：11.15 ～ 12.12</strong></li>
<li>组委会整理报名资料：12.12-12.14</li>
<li>开发：12.15 ～ 12.18</li>
<li><strong>作品提交：12.19</strong></li>
<li>作品初评：12.20 ～ 12.25 （评委会 + 社区投票）</li>
<li>大赛线上路演：12.29（线上直播 ：14:00 ～ 18:00）+ 观众投票 + 社区媒体</li>
<li>作品颁奖：12.30</li>
</ul>
<p><strong>（如上述安排有调整，小助手会第一时间提前告知各位参赛人员，请务必报名后联系小助手入群）</strong></p>
<p><img src="${s}" alt="图片"></p>
<p><strong>扫码加小助手入群，备注：Rust 参赛</strong></p>
<h2 id="参赛福利">参赛福利</h2>
<p>本次 hackathon 大赛设有一、二、三等奖各一组，除此之外为鼓励大家积极参与，组委会还另外设置了 5 组最佳参与奖。奖品更是丰富多样：不仅包含高额奖金，更有社区限量大礼包，甚至还有社区访谈。除此以外，我们还为参赛者谋取了更多的福利：譬如，你将会体验到前所未有的与线上同好进行技术交流的友好氛围，以及收获到评委大咖的资深点评。</p>
<h2 id="赛题评审">赛题评审</h2>
<p>本次大赛将由<strong>企业组</strong>与<strong>社区专家</strong>两组评审团共同评审，对基础的代码完成情况和整体作品的性能表现两方面同时进行评分，且二者占比相同。</p>
<h2 id="参赛及代码提交">参赛及代码提交</h2>
<ul>
<li>参加本次 Hackathon 的每个队伍只能选择参加一个赛题，每队成员限 1 ～ 5 人。</li>
</ul>
<p><img src="${n}" alt="图片"></p>
<ul>
<li>
<p><strong>扫码参赛报名，每个 ID 仅限 1 次</strong></p>
</li>
<li>
<p>第一行代码 commit 的时间不得早于 12 月 15 日，否则即视为违规，取消参赛资格。为防止队伍之间的代码冲突，每支参赛队伍需要自己创建一个独立。即每个项目需要以一个独立目录提交，且文件名为团队拼音。</p>
</li>
<li>
<p>代码需统一提交至：<br>
<strong><a href="https://github.com/datenlord/rustChinaHackathon22%E3%80%82">https://github.com/datenlord/rustChinaHackathon22。</a></strong></p>
</li>
</ul>
<h2 id="赛题剖析">赛题剖析</h2>
<p>在赛事流程介绍完毕后，<strong>达坦科技联合创始人兼 CTO 施继成先生</strong>进行本次企业组赛题的介绍。他从当今云计算发展的宏观角度出发，不同的云厂商提供着各种不同的云服务，而一些大企业的内部也建有各独立的私有云。由此，云与云之间的阻隔带来了诸多问题，譬如：一旦选择其一种云服务后，如想将数据导出则变得无比困难。为了解决这个问题，海外学界有人提出了天空计算的概念，旨在解决云之间的隔阂问题，将云服务商（cloud vendor）变成基础设施提供商。<strong>达坦科技的开源项目 Xline</strong> 正是在这个背景下应运而生。</p>
<p>与普通的 KV 不同，Xline 是专门应用于全球部署、多集群的情况下的分布式存储 KV。它不仅拥有统一的元数据管理系统，同时也保证了在多数据中心情况下的高性能实现。为了给用户带来更多便利，Xline 同时也兼容 ETCD interface。而我们使用的 CURP 共识协议也可以保证即使在分布式的情况下，不同 server 间也保持着同频共振。</p>
<p>Xline KV 中设有索引，起到了定位器的作用，可以快速定位数据，同时进行“增删改查”的工作。它能够处理并发操作、Range 操作，其最简单的实现是 Lock+Btree，但是这也带来了不能 scale 的问题，即当用户访问量过大时就会受到影响。</p>
<p>本场赛题正是基于此展开的。题目要求实现一个高速并发的 Index 数据结构，满足以下 Trait；同时到达的请求 Key 不会出现 overlap。在并发数据结构的设计以及支持高速 Range 操作（保续）方面是有一定技术难度的，但我们也相信在诸位优秀青年才俊的努力下，更完善的解决方案将会被提出，更多思想火花可以得到释放，技术难题也将被攻破。</p>
<p><img src="${a}" alt="图片"></p>
<h2 id="达坦科技-datenlord-赛题">达坦科技 DatenLord 赛题</h2>
<p><strong>主题</strong><br>
Concurrent Indexing</p>
<p><strong>背景</strong><br>
Xline 是达坦科技推出的分布式元数据 KV 存储器。在使用中，此系统需要处理来自客户端的高并发请求，数目有时甚至可以扩展到数百至数千个。为了在内存中定位到相应 KV 数据，我们维护了一个索引，而此索引也成为了整个系统的瓶颈之一。在这样的情况下，如何提高索引在处理并发请求时的性能就成为了一个问题。</p>
<p><strong>挑战</strong><br>
在本次 Hackathon 中，你将需要通过创建这样一个并发索引来解决此问题，此索引应该满足以下要求：</p>
<ol>
<li>客户端将并发地发送请求，但并不会发送冲突的请求。</li>
<li>无冲突的请求应当被并发执行，以提高生产量。</li>
</ol>
<pre><code class="hljs language-rust"><span class="hljs-comment">/// Operations of Index</span>
<span class="hljs-title function_ invoke__">pub</span>(<span class="hljs-keyword">crate</span>) <span class="hljs-keyword">trait</span> <span class="hljs-title class_">IndexOperate</span>&#x3C;K: <span class="hljs-built_in">Ord</span>, V> {
    <span class="hljs-comment">/// Get a range of keys in [key, range_end]</span>
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">get</span>(&#x26;<span class="hljs-keyword">self</span>, key: &#x26;K, range_end: &#x26;K) <span class="hljs-punctuation">-></span> <span class="hljs-type">Vec</span>&#x3C;&#x26;V>;
    <span class="hljs-comment">/// delete a range of keys in [key, range_end]</span>
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">delete</span>(&#x26;<span class="hljs-keyword">self</span>, key: &#x26;K, range_end: &#x26;K) <span class="hljs-punctuation">-></span> <span class="hljs-type">Vec</span>&#x3C;V>;
    <span class="hljs-comment">/// insert of update a key</span>
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">insert_or_update</span>(&#x26;<span class="hljs-keyword">self</span>, key: K, value: V) <span class="hljs-punctuation">-></span> <span class="hljs-type">Option</span>&#x3C;V>;
}
</code></pre>
<p><strong>评估标准</strong><br>
你的实现应遵从上述 Trait 并满足上述要求。我们将使用一定基准测试来进行评估，并根据其结果评分。在基准测试中，我们将发送大量并发请求，因此你也可以创建自己的性能测试来帮助进行优化。</p>`;export{e as assetURLs,p as default,l as metadata,o as toc};
