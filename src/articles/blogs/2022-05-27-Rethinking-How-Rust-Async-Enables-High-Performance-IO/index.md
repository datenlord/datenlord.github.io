---
label: 重新思考Rust Async如何实现高性能IO
description: 长期以来，计算机系统IO的速度一直没能跟上CPU速度的提升，相比而言IO往往成为系统的性能瓶颈，计算任务等待IO存取数据，成为高性能系统的一大性能瓶颈。本文先剖析IO性能瓶颈的根源，然后举例说明如何解决IO瓶颈，最后简要介绍我们在高性能IO方面的尝试。
location: 河南
author: [王璞]
tags: [Rust]
---

长期以来，计算机系统 IO 的速度一直没能跟上 CPU 速度的提升，相比而言 IO 往往成为系统的性能瓶颈，计算任务等待 IO 存取数据，成为高性能系统的一大性能瓶颈。本文先剖析 IO 性能瓶颈的根源，然后举例说明如何解决 IO 瓶颈，最后简要介绍我们在高性能 IO 方面的尝试。

###　 IO 性能瓶颈
当用户程序执行 IO 操作时，绝大多数情况下是调用操作系统内核提供的系统调用来执行 IO 操作，最常见的 IO 系统调用是 read 和 write。在现代计算机体系结构和操作系统的架构下，导致程序 IO 性能瓶颈主要有三大因素：阻塞、上下文切换、内存拷贝。下面分别简述为什么这三个因素会导致程序性能下降。

### 阻塞

阻塞比较好理解，比如用户程序调用 read 系统调用来读取数据，如果要读取的数据没有准备好（没有命中缓存），那用户程序就会被阻塞，导致用户程序休眠。等要读的数据加载到系统态的内存之后，内核再唤醒用户程序来读取数据。

阻塞对用户程序性能最大的影响在于，用户程序会被强制休眠，而且用户程序什么时候被唤醒也无法控制，程序休眠期间什么都不能做。于是阻塞带来了大量的休眠等待时间。如果程序把大量时间花在阻塞等待 IO 上，自然 IO 效率低下，进而导致程序性能受影响。

### 上下文切换

上下文切换是操作系统的基本概念。内核运行在系统态，用户程序运行在用户态，这么做主要是处于安全的考虑，限制用户程序的权限。用户程序调用系统调用执行 IO 操作，会发生上下文切换，比如用户程序调用 read 系统调用来读取数据，用户程序的上下文被保存起来，然后切换到内核态执行 read 系统调用，当 read 系统调用执行完毕，再切换回用户程序。

上下文切换的代价不小，一方面内核要保存上下文现场，另一方面 CPU 的流水线也会被上下文切换打断，需要重新加载指令。上下文切换等同一次中断操作，于是系统调用也被称软中断。频繁的上下文操作对计算机系统带来很大的开销，导致程序执行效率大大降低，进而极大影响程序的性能。

此外，阻塞的时候，一定会发生上下文切换。还是沿用 read 操作的例子，用户程序在调用 read 系统调用后，内核发现要读的数据没有命中缓存，那用户程序会被强制休眠导致阻塞，内核调度其他程序来运行。但是上下文切换的时候不一定有阻塞。比如 read 操作的时候，如果用户程序在调用 read 系统调用之后，缓存命中，则 read 系统调用成功返回，把该用户程序的上下文切换回来继续运行。

### 内存拷贝

内存拷贝对程序性能的影响主要源于内存的访问速度跟不上 CPU 的速度，加之内存的访问带宽有限，亦称内存墙（Memory Wall）。

现在的 CPU 频率都是几个 GHz，每个 CPU 指令的执行时间在纳秒量级。但是 CPU 访问内存要花很多时间，因为 CPU 发出读取内存的指令后，不是马上能拿到数据，要等一段时间。CPU 访问内存的延迟大约在几十纳秒量级，比 CPU 指令的执行时间差不多慢一个数量级。

再者，内存的访问带宽也是有限的，DDR4 内存总的带宽大约几十 GB 每秒。虽然看着不小，但是每个程序在运行时都要访问内存，不论是加载程序指令，执行计算操作，还是执行 IO 操作，都需要访问内存。

当发生内存拷贝时，CPU 把数据从内存读出来，再写到内存另外的地方。由于内存访问延迟比 CPU 指令执行时间慢很多，再加上内存带宽有限，于是 CPU 也不是随时能访问内存，CPU 的访存指令会在 DDR 控制器的队列里排队。因此内存拷贝对于 CPU 来说是很花时间的操作，数据没有从内存读出来就不能执行后续写入操作，导致大量 CPU 等待，使得程序性能下降。

## 如何实现高性能 IO

针对上面提到的三种影响 IO 性能的因素，下面举三个例子，Rust Async，io_uring 和 RDMA，分别来介绍如何解决这三种影响程序性能的 IO 问题。

### Rust Async

Rust Async 异步编程通过协程、waker 机制，部分解决了阻塞和上下文切换的问题。

首先，Rust Async 采用协程机制，在某个异步任务被阻塞后，自行切换执行下一个异步任务，一方面避免了工作线程被阻塞，另一方面也避免了工作线程被内核上下文切换。Rust Async 底层依靠操作系统的异步机制，比如 Linux 的 epoll 机制，来通知 IO 是否完成，进而唤醒 waker 来调度异步任务。

但是，Rust Async 仍然有阻塞。Rust Async 里工作线程没有被阻塞，不过被阻塞的是 waker，所以 Rust Async 是把阻塞从工作线程搬到了 waker 身上。

此外，Rust Async 无法避免上下文切换。Rust Async 采用 Reactor 的 IO 方式：比如用户程序要读取数据，发起 read 异步任务，假定该任务被阻塞放到等待队列，当该任务要读取的数据被内核准备好之后，该任务被唤醒，继续调用 read 系统调用把数据从内核里读到用户内存空间，这次 read 系统调用因为要读的数据已经被内核加载到系统态内存里，所以不会发生阻塞，但是 read 系统调用还会有上下文切换。

Rust Async 运行在用户态，而阻塞和上下文切换是操作系统内核决定的。要想进一步避免阻塞和上下文切换，就得在内核上做文章。

###　 io_uring

io_uring 是 Linux 提供的原生异步接口，不仅支持异步 IO，还可以支持异步系统调用。io_uring 在内核与用户程序之间建立发送队列 SQ 和完成队列 CQ，用户程序把 IO 请求通过 SQ 发给内核，然后内核把 IO 执行完毕的消息通过 CQ 发给用户程序。采用 io_uring，一方面避免了阻塞，另一方面也避免了上下文切换。

io_uring 采用 Proactor 的 IO 方式，Proactor 是相对 Reactor 而言。比如用户程序采用 io_uring 来读取数据，先把 read 请求放到发送队列 SQ，然后用户程序可以去执行其他任务，或者定期轮询完成队列 CQ（当然用户程序也可以选择休眠被异步唤醒，但这样就会有上下文切换，不过这个上下文切换是用户程序自行选择的）。IO 完成的时候，io_uring 会把用户程序要读的数据加载到 read 请求里的 buffer，然后 io_uring 在 CQ 里放入完成消息，通知用户程序 IO 完成。这样当用户程序收到 CQ 里的完成消息后，可以直接使用 read 请求 buffer 里的数据，而不需要再调用 read 系统调用来加载数据。

所以 io_uring 通过内核的支持，可以实现无阻塞和无上下文切换，进一步提升了 IO 的性能。但是 io_uring 还无法避免内存拷贝，比如 read 操作的时候，数据是先从 IO 设备读到内核空间的内存里，然后内核空间的数据再在复制到用户空间的内存。内核这么做是出于安全和简化 IO 的考虑。但是要想避免内存拷贝，那就得实现内核旁路（kernel bypass），避免内核参与 IO。

###　 RDMA

RDMA 是常用于超算中心、高端存储等领域的高性能网络方案。RDMA 需要特殊的网卡支持，RDMA 网卡具有 DMA 功能，可以实现 RDMA 网卡直接访问用户态内存空间。在 RDMA 网卡和用户态内存之间的数据传输（即数据通路），完全不需要 CPU 参与，更无需内核参与。用户程序通过 RDMA 传输数据时，是调用 RDMA 的用户态 library 接口，然后直接和 RDMA 网卡打交道。所以 RDMA 传输数据的整个数据通路是在用户态完成，没有内核参与，既没有阻塞也没有上下文切换，更没有内存拷贝，因此采用 RDMA 可以获得非常好的网络 IO 性能。

虽然 RDMA 通过内核旁路避免了阻塞、上下文切换和内存拷贝，实现了高性能网络 IO，但是 RDMA 也是有代价的。首先，RDMA 编程复杂度大大提高，RDMA 有自己的编程接口，不再采用内核提供的 socket 接口，RDMA 的接口偏底层，而且调试不够友好。另外，用户程序采用 RDMA 之后要自行管理内存，保证内存安全，避免竞争访问：比如用户要通过 RDMA 网路发送数据，在数据没有发送完成前，用户程序要保证存放待发送数据的用户内存空间不能被修改，不然会导致发送的数据错误，而且即便用户程序在已经开始发送但还没有发送完成前修改了待发送的数据，RDMA 也不会报错，因为 RDMA 的用户态 library 也无法控制用户程序的内存空间来保证数据一致性。这极大地增加了用户程序的开发难度。对比内核执行写操作，用户程序调用 write 系统调用之后，内核把待写的数据先缓存在内核空间的内存，然后就可以通知用户程序写操作完成，回头内核再把写数据写入设备。虽然内核有做内存拷贝，但是保证了数据一致性，，也降低了用户程序执行 IO 操作的开发复杂度。

## 我们的尝试

DatenLord 的目标是打造高性能分布式存储系统，我们在开发 DatenLord 的过程中，一直在探索如何实现高性能 IO。

虽然 Rust Async 异步编程理念非常不错，用类似同步 IO 语意实现异步 IO。但是我们认为 Rust Async 更多是异步 IO 的编程框架，还称不上是高性能 IO 框架。于是我们尝试把 Rust Async 跟 io_uring 和 RDMA 结合，以实现高性能 IO。

首先，Rust Async 与 io_uring 的结合工作，虽然 Rust 社区在这方面也有不少类似的尝试，但是我们的重点是如何在 io_uring 执行异步 IO 的时候避免内存拷贝，这方面 Rust 社区的工作还很少。我们尝试采用 Rust 的 ownership 机制来防止用户程序修改提交给 io_uring 用于执行 IO 操作的用户态内存，一方面避免内存拷贝，一方面保证内存安全。感兴趣的朋友可以看下 **ring-io**。

另外，我们也在尝试结合 Rust Async 与 RDMA，这方面 Rust 社区的工作不多。RDMA 性能虽好，但是开发复杂度很大，而且调试不友好。我们尝试采用 Rust friendly 的方式来实现 RDMA 接口的异步封装，同时解决 RDMA 程序需要开发者自行管理内存的问题，从而大大降低采用 Rust 开发 RDMA 程序的难度。感兴趣的朋友可以看下 **async-rdma**。

最后，欢迎对高性能 IO 感兴趣的朋友们联系我们，跟我们一起交流探讨。  
我们的联系方式：**dev@datenlord.io**
