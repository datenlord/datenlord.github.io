const s="/assets/image1-b7dc7038.webp",n="data:image/webp;base64,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",a=[s,n],e={title:"Understanding Functor in Rust",description:"In this blog, we introduce the general concept of Functor and Natural Transformations.",cover:"./image1.webp",author:[{name:"Zqa",age:"23?"},{name:"LingKa",age:21}],tags:["xline"],date:"2022-07-21"},t=[{label:"Understanding Functor in Rust",level:2},{label:"What is a category?",level:2},{label:"Option Functor",level:2},{label:"Definition of Functor",level:2},{label:"Implement functor in rust",level:2},{label:"Natural Transformation",level:2}],p=`<h1>Understanding Functor in Rust</h1>
<h2 id="understanding-functor-in-rust">Understanding Functor in Rust</h2>
<p>In this blog, we introduce the general concept of Functor and Natural Transformations. The blog provides examples of Rust, but we will explain more about its concepts and definitions in the following sections.</p>
<p>In mathematics, a functor is a mapping between categories. It’s an obscure definition and looks horrible if you don’t like math. But don’t worry. Let’s look at an example.</p>
<p>Suppose you have a mapping that plus one. Then if you pass an integer, it will plus it with 1. What if you pass a list of integers? It does not work if we add one to the list directly. However, we could use the map function.</p>
<pre><code class="hljs language-rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">f</span> = |x| <span class="hljs-punctuation">-></span> <span class="hljs-type">i32</span> { x + <span class="hljs-number">1</span> };
<span class="hljs-keyword">let</span> <span class="hljs-variable">y</span> = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].<span class="hljs-title function_ invoke__">map</span>(f);
<span class="hljs-built_in">assert_eq!</span>([<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>], y);
</code></pre>
<p>In fact, Functor is just a way to preserve the structure.</p>
<hr>
<h2 id="what-is-a-category?">What is a category?</h2>
<p>Back to the previous question, what is a category?</p>
<p>A category C has objects, morphisms, and binary operation ∘ , which is called the composition of morphisms. In this context, we could view types as objects and their functions as morphisms. These functions could be composited with∘ . The (f ∘ g)(x) means apply f to g(x) . ie. (f ∘ g)(x) = f(g(x))</p>
<p>Composition is governed by two axioms:</p>
<ol>
<li>Associativity: if f : a → b , g : b → c and h : c → d then h ∘ (g ∘ f) = (h ∘ g) ∘ f</li>
<li>Identity: For every object x, there exists an identity morphism 1x : x → x such that for every morrphism f : a → b , 1b ∘ f = f = f ∘ 1a</li>
</ol>
<h2 id="option-functor">Option Functor</h2>
<pre><code class="hljs language-rust"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Option</span>&#x3C;T> { <span class="hljs-title function_ invoke__">Some</span>(T), <span class="hljs-literal">None</span> }
</code></pre>
<p>In Rust, we have Option type, which is either some value of type T or it is no value. As a Functor, it is not only a mapping from T to Option<t>, but also a mapping of functions. Option implements it as a map method.</t></p>
<pre><code class="hljs language-rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">map</span>&#x3C;U, F>(<span class="hljs-keyword">self</span>, f: F) <span class="hljs-punctuation">-></span> <span class="hljs-type">Option</span>&#x3C;U> {
   <span class="hljs-keyword">match</span> <span class="hljs-keyword">self</span> {
     <span class="hljs-title function_ invoke__">Some</span>(x) => <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-title function_ invoke__">f</span>(x)),
     <span class="hljs-literal">None</span> => <span class="hljs-literal">None</span>,
   }
}
</code></pre>
<p>if f is a function that maps from T to U. The method map f from Option<t> to Option<code>&#x3C;U></code> . Some(x) is a mapping between objects, which can either be primitive type or higher kinded type, while the map method is the mapping between morphisms.</t></p>
<hr>
<h2 id="definition-of-functor">Definition of Functor</h2>
<p>So far, we go through the basic concept of functor and option as an example. Now let’s deep dive into the definition of Functor.</p>
<p>A Functor F : C → D is a mapping that</p>
<ol>
<li>map each type X in C to a type F(X) in D</li>
<li>map each function f : X → Y in C to a function F(f) : F(X) → F(Y ) in D s.t
<ul>
<li>idF (X) for every X in C</li>
<li>F(g ∘ f) = F(g) ∘ F(f) for all f : X → Y and g : Y → Z in C</li>
</ul>
</li>
</ol>
<p><img src="${s}" alt="image1"></p>
<p>The Functor F not only maps objects X, Y, Z in C to F(X), F(Y), F(Z) in D, but also maps f, g, h in C to F(f), F(g), F(h) in D. It preserves the structure including the composition of morphisms. In this context, functions are maps between types inside the category. But Functor maps the whole structure formed by types and functions to another category.</p>
<p>Getting back to the option functor, how can it be proved to be a functor?</p>
<p>By definition of Functor, we need to prove that maps preserve identity and composition.</p>
<p>Condition 1: Identity</p>
<p>None Case:</p>
<pre><code class="hljs language-rust"><span class="hljs-built_in">assert_eq!</span>(<span class="hljs-literal">None</span>.<span class="hljs-title function_ invoke__">map</span>(id), <span class="hljs-literal">None</span>); <span class="hljs-comment">// By definition of map</span>
<span class="hljs-built_in">assert_eq!</span>(<span class="hljs-literal">None</span>, <span class="hljs-title function_ invoke__">id</span>(<span class="hljs-literal">None</span>)); <span class="hljs-comment">// By definition of id</span>
</code></pre>
<p>Some Case:</p>
<pre><code class="hljs language-rust"><span class="hljs-built_in">assert_eq!</span>(<span class="hljs-title function_ invoke__">Some</span>(x).<span class="hljs-title function_ invoke__">map</span>(id), <span class="hljs-title function_ invoke__">Some</span>(x)); <span class="hljs-comment">// By definition of map</span>
<span class="hljs-built_in">assert_eq!</span>(<span class="hljs-title function_ invoke__">Some</span>(x), <span class="hljs-title function_ invoke__">id</span>(<span class="hljs-title function_ invoke__">Some</span>(x))); <span class="hljs-comment">// By definition of id</span>
</code></pre>
<p>Condition 2: Composition</p>
<p>None Case:</p>
<pre><code class="hljs language-rust"><span class="hljs-built_in">assert_eq!</span>(<span class="hljs-literal">None</span>.<span class="hljs-title function_ invoke__">map</span>(f).<span class="hljs-title function_ invoke__">map</span>(g), <span class="hljs-literal">None</span>.<span class="hljs-title function_ invoke__">map</span>(g)); <span class="hljs-comment">// By definition of map</span>
<span class="hljs-built_in">assert_eq!</span>(<span class="hljs-literal">None</span>.<span class="hljs-title function_ invoke__">map</span>(g), <span class="hljs-literal">None</span>); <span class="hljs-comment">// By definition of map</span>
<span class="hljs-built_in">assert_eq!</span>(<span class="hljs-literal">None</span>, <span class="hljs-literal">None</span>.<span class="hljs-title function_ invoke__">map</span>(|x| <span class="hljs-title function_ invoke__">g</span>(<span class="hljs-title function_ invoke__">f</span>(x)))); <span class="hljs-comment">// By definition of map</span>
</code></pre>
<p>Some Case:</p>
<pre><code class="hljs language-rust"><span class="hljs-built_in">assert_eq!</span>(<span class="hljs-title function_ invoke__">Some</span>(x).<span class="hljs-title function_ invoke__">map</span>(f).<span class="hljs-title function_ invoke__">map</span>(g), <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-title function_ invoke__">f</span>(x)).<span class="hljs-title function_ invoke__">map</span>(g)); <span class="hljs-comment">// By definition of map</span>
<span class="hljs-built_in">assert_eq!</span>(<span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-title function_ invoke__">f</span>(x)).<span class="hljs-title function_ invoke__">map</span>(g), <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-title function_ invoke__">g</span>(<span class="hljs-title function_ invoke__">f</span>(x)))); <span class="hljs-comment">// By definition of composition</span>
<span class="hljs-built_in">assert_eq!</span>(<span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-title function_ invoke__">g</span>(<span class="hljs-title function_ invoke__">f</span>(x))), <span class="hljs-title function_ invoke__">Some</span>(x).<span class="hljs-title function_ invoke__">map</span>(|x| <span class="hljs-title function_ invoke__">g</span>(<span class="hljs-title function_ invoke__">f</span>(x)))) <span class="hljs-comment">// By definition of map</span>
</code></pre>
<p>Therefore, The Option type constructor and map method form a Functor.</p>
<hr>
<h2 id="implement-functor-in-rust">Implement functor in rust</h2>
<p>There are various opinions about the implementation of the functor in rust. Due to the limitations of the rust language, some of them are still ideal. Here I would recommend one attempt, which could be implemented by using generic_associated_types(GAT).</p>
<pre><code class="hljs language-rust"><span class="hljs-keyword">trait</span> <span class="hljs-title class_">Functor</span> {
    <span class="hljs-keyword">type</span> <span class="hljs-title class_">Unwrapped</span>;
    <span class="hljs-keyword">type</span> <span class="hljs-title class_">Wrapped</span>&#x3C;B>: Functor;
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">map</span>&#x3C;F, B>(<span class="hljs-keyword">self</span>, f: F) <span class="hljs-punctuation">-></span> <span class="hljs-keyword">Self</span>::Wrapped&#x3C;B>
    <span class="hljs-keyword">where</span>
        F: <span class="hljs-title function_ invoke__">FnMut</span>(<span class="hljs-keyword">Self</span>::Unwrapped) <span class="hljs-punctuation">-></span> B;
}
</code></pre>
<p>In this trait, there are two associated types. Unwrapped represents the inner type and Wrapped represents the type containing B type inside.</p>
<p>Taking Option as an example, If we have an Unwrapped type A, then the Wrapped type should be Option<code>&#x3C;A></code>. F is a function from A to B. The map method combines the function mapping Ff and sends self as input. Thus, we have Option<code>&#x3C;B></code> directly. If we only consider Ff , we can define fmap</p>
<pre><code class="hljs language-rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">fmap</span>&#x3C;F, A, B>(<span class="hljs-keyword">mut</span> f: F) <span class="hljs-punctuation">-></span> <span class="hljs-keyword">impl</span> <span class="hljs-title class_">FnMut</span>(<span class="hljs-type">Option</span>&#x3C;A>) <span class="hljs-punctuation">-></span> <span class="hljs-type">Option</span>&#x3C;B>
<span class="hljs-keyword">where</span>
    F: <span class="hljs-title function_ invoke__">FnMut</span>(A) <span class="hljs-punctuation">-></span> B
{
    <span class="hljs-keyword">move</span> |x| <span class="hljs-punctuation">-></span> <span class="hljs-type">Option</span>&#x3C;B>
    {
        <span class="hljs-keyword">match</span> x {
            <span class="hljs-title function_ invoke__">Some</span>(x) => <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-title function_ invoke__">f</span>(x)),
            <span class="hljs-literal">None</span> => <span class="hljs-literal">None</span>,
        }
    }
}
<span class="hljs-built_in">assert_eq!</span>(<span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-number">6</span>), <span class="hljs-title function_ invoke__">fmap</span>(|x: <span class="hljs-type">i32</span>| x + <span class="hljs-number">1</span>)(<span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-number">5</span>)));
</code></pre>
<p>The map method not only contains Ff , it also gives the input, which is one step further.</p>
<p>Imagine implementing a Functor trait for Option. we could have</p>
<pre><code class="hljs language-rust"><span class="hljs-keyword">impl</span>&#x3C;A> Functor <span class="hljs-keyword">for</span> <span class="hljs-title class_">Option</span>&#x3C;A> {
    <span class="hljs-keyword">type</span> <span class="hljs-title class_">Unwrapped</span> = A;
    <span class="hljs-keyword">type</span> <span class="hljs-title class_">Wrapped</span>&#x3C;B> = <span class="hljs-type">Option</span>&#x3C;B>;
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">map</span>&#x3C;B, F>(<span class="hljs-keyword">self</span>, f: F) <span class="hljs-punctuation">-></span> <span class="hljs-type">Option</span>&#x3C;B>
    <span class="hljs-keyword">where</span>
        F: <span class="hljs-title function_ invoke__">FnMut</span>(<span class="hljs-keyword">Self</span>::Unwrapped) <span class="hljs-punctuation">-></span> B,
    {
        <span class="hljs-keyword">self</span>.<span class="hljs-title function_ invoke__">map</span>(f)
    }
}
</code></pre>
<p>However, there is one drawback. If we assign Wrapped to a Result type, the structure-preserve property would be broken. But the compiler won’t check that.</p>
<hr>
<h2 id="natural-transformation">Natural Transformation</h2>
<p>We talk about Functors as structure-preserving maps between categories. Derivation from Functors, there is a more abstract concept, Natural transformations. It maps functors to functors.</p>
<p>Suppose we have two categories C and D, and two functors F and G that map a in C to Fa and Ga.</p>
<p><img src="${n}" alt="image2"></p>
<p>A natural transformation is a family of morphisms from F to G. The morphism is called the component of at a. In other words, natural transformation is indexed by the object in the domain category C.</p>
<p>If for some x in C, there is no morphism from Fx to Gx, then there can be no natural transformation between F and G. Because natural transformation also needs to preserve the internal structure. It looks very similar to the functor. It can be considered as a morphism of functors.</p>
<p>Because Functor also maps morphisms, if we have a function maps from a to b. Functor will give you mapping from Fa to Fb. Similarly, we have Gf from Ga to Gb. Through the commutative diagram, we could find there are two ways from Fa to Gb. It gives us an equation.</p>
<p>αb ∘ Ff = Gf ∘ αa</p>
<p>If components satisfy the equation for every f in C, combined with the previous condition, we have a natural transformation α .</p>
<p>Taking pop method of Vec as an example.</p>
<pre><code class="hljs language-rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">vec</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];
<span class="hljs-built_in">assert_eq!</span>(<span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-number">3</span>), vec.<span class="hljs-title function_ invoke__">pop</span>());
</code></pre>
<p>The pop method mapping from a Vec Functor to Option Functor. We could regards it as . Suppose we have a plus one function.</p>
<pre><code class="hljs language-rust"><span class="hljs-comment">// αb∘Ff </span>
<span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">vec</span>:<span class="hljs-type">Vec</span>&#x3C;<span class="hljs-type">i32</span>> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].<span class="hljs-title function_ invoke__">into_iter</span>().<span class="hljs-title function_ invoke__">map</span>(|x| x+<span class="hljs-number">1</span>).<span class="hljs-title function_ invoke__">collect</span>(); 
<span class="hljs-built_in">assert_eq!</span>(<span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-number">4</span>), vec.<span class="hljs-title function_ invoke__">pop</span>()); 
<span class="hljs-comment">// Gf∘αa </span>
<span class="hljs-keyword">let</span> <span class="hljs-variable">last</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].<span class="hljs-title function_ invoke__">pop</span>(); 
<span class="hljs-built_in">assert_eq!</span>(<span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-number">4</span>), last.<span class="hljs-title function_ invoke__">map</span>(|x| x+<span class="hljs-number">1</span>));
</code></pre>
<p>Because rust iterators are lazy, we need to use a collect() method to make new elements, which combines the map method as . We use two different ways to send Vec to Option, and both give the same result.</p>`;export{a as assetURLs,p as default,e as metadata,t as toc};
